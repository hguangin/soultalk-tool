<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¨­å®š - SoulTalk Tool</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <!-- é ‚éƒ¨å°èˆª -->
        <header class="header">
            <h1>âš™ï¸ è¨­å®šä¸­å¿ƒ</h1>
            <nav>
                <a href="/">åŸ·è¡Œå·¥ä½œ</a>
                <a href="/settings.html" class="active">âš™ï¸ è¨­å®š</a>
            </nav>
        </header>

        <!-- ä¸»è¦å…§å®¹ -->
        <main class="main settings-page">
            <!-- åˆ†é¡é¸å–® -->
            <aside class="sidebar">
                <h3>è¨­å®šåˆ†é¡</h3>
                <ul id="categoryList" class="category-list">
                    <li class="loading">è¼‰å…¥ä¸­...</li>
                </ul>
                
                <div class="sidebar-actions">
                    <button id="btnTestNotify" class="btn btn-small">ğŸ“± æ¸¬è©¦é€šçŸ¥</button>
                </div>
            </aside>

            <!-- è¨­å®šå…§å®¹ -->
            <section class="settings-content">
                <div class="settings-header">
                    <h2 id="categoryTitle">é¸æ“‡åˆ†é¡</h2>
                    <button id="btnSave" class="btn btn-primary" disabled>ğŸ’¾ å„²å­˜è®Šæ›´</button>
                </div>
                
                <div id="settingsForm" class="settings-form">
                    <p class="placeholder">â† è«‹å¾å·¦å´é¸æ“‡è¨­å®šåˆ†é¡</p>
                </div>
            </section>
        </main>

        <!-- è¨Šæ¯æç¤º -->
        <div id="toast" class="toast"></div>
    </div>

    <script>
    /**
     * ============================================================================
     * è¨­å®šé é¢çš„å‰ç«¯ç¨‹å¼
     * ============================================================================
     */

    // ç‹€æ…‹
    let categories = [];
    let currentCategory = null;
    let currentSettings = [];
    let hasChanges = false;

    // DOM å…ƒç´ 
    const categoryList = document.getElementById('categoryList');
    const categoryTitle = document.getElementById('categoryTitle');
    const settingsForm = document.getElementById('settingsForm');
    const btnSave = document.getElementById('btnSave');
    const btnTestNotify = document.getElementById('btnTestNotify');
    const toast = document.getElementById('toast');

    // ========== åˆå§‹åŒ– ==========
    async function init() {
        await loadCategories();
        
        btnSave.addEventListener('click', saveSettings);
        btnTestNotify.addEventListener('click', testNotification);
    }

    // ========== è¼‰å…¥åˆ†é¡ ==========
    async function loadCategories() {
        try {
            const res = await fetch('/api/settings/categories');
            const data = await res.json();
            
            if (data.success) {
                categories = data.categories;
                renderCategories();
            }
        } catch (error) {
            showToast('è¼‰å…¥åˆ†é¡å¤±æ•—: ' + error.message, 'error');
        }
    }

    function renderCategories() {
        categoryList.innerHTML = categories.map(cat => `
            <li data-id="${cat.id}" onclick="selectCategory('${cat.id}')">
                ${cat.name}
            </li>
        `).join('');
    }

    // ========== é¸æ“‡åˆ†é¡ ==========
    async function selectCategory(categoryId) {
        // å¦‚æœæœ‰æœªå„²å­˜çš„è®Šæ›´ï¼Œæé†’
        if (hasChanges) {
            if (!confirm('æœ‰æœªå„²å­˜çš„è®Šæ›´ï¼Œç¢ºå®šè¦é›¢é–‹å—ï¼Ÿ')) {
                return;
            }
        }

        currentCategory = categoryId;
        
        // æ›´æ–°é¸ä¸­ç‹€æ…‹
        document.querySelectorAll('.category-list li').forEach(li => {
            li.classList.toggle('active', li.dataset.id === categoryId);
        });

        // è¼‰å…¥è¨­å®š
        try {
            const res = await fetch(`/api/settings/category/${categoryId}`);
            const data = await res.json();
            
            if (data.success) {
                currentSettings = data.settings;
                renderSettings();
                
                // æ›´æ–°æ¨™é¡Œ
                const cat = categories.find(c => c.id === categoryId);
                categoryTitle.textContent = cat ? cat.name : categoryId;
            }
        } catch (error) {
            showToast('è¼‰å…¥è¨­å®šå¤±æ•—: ' + error.message, 'error');
        }
    }

    // ========== æ¸²æŸ“è¨­å®šè¡¨å–® ==========
    function renderSettings() {
        if (currentSettings.length === 0) {
            settingsForm.innerHTML = '<p class="placeholder">æ­¤åˆ†é¡æ²’æœ‰è¨­å®šé …ç›®</p>';
            return;
        }

        settingsForm.innerHTML = currentSettings.map(s => {
            const inputHtml = renderInput(s);
            return `
                <div class="setting-item">
                    <label for="setting-${s.key}">${s.label || s.key}</label>
                    ${inputHtml}
                    ${s.description ? `<p class="setting-desc">${s.description}</p>` : ''}
                </div>
            `;
        }).join('');

        // ç›£è½è®Šæ›´
        settingsForm.querySelectorAll('input, select, textarea').forEach(el => {
            el.addEventListener('change', () => markChanged());
            el.addEventListener('input', () => markChanged());
        });

        hasChanges = false;
        btnSave.disabled = true;
    }

    function renderInput(setting) {
        const id = `setting-${setting.key}`;
        const value = setting.value || '';

        switch (setting.type) {
            case 'password':
                return `<input type="password" id="${id}" data-key="${setting.key}" value="${escapeHtml(value)}" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢">`;
            
            case 'number':
                return `<input type="number" id="${id}" data-key="${setting.key}" value="${escapeHtml(value)}">`;
            
            case 'boolean':
                const checked = value === 'true' ? 'checked' : '';
                return `
                    <label class="toggle">
                        <input type="checkbox" id="${id}" data-key="${setting.key}" ${checked}>
                        <span class="toggle-slider"></span>
                    </label>
                `;
            
            case 'color':
                return `<input type="color" id="${id}" data-key="${setting.key}" value="${escapeHtml(value)}">`;
            
            case 'select':
                const options = (setting.options || '').split(',').map(opt => {
                    const selected = opt.trim() === value ? 'selected' : '';
                    return `<option value="${opt.trim()}" ${selected}>${opt.trim()}</option>`;
                }).join('');
                return `<select id="${id}" data-key="${setting.key}">${options}</select>`;
            
            case 'textarea':
            case 'json':
                return `<textarea id="${id}" data-key="${setting.key}" rows="6">${escapeHtml(value)}</textarea>`;
            
            default:
                return `<input type="text" id="${id}" data-key="${setting.key}" value="${escapeHtml(value)}">`;
        }
    }

    // ========== å„²å­˜è¨­å®š ==========
    async function saveSettings() {
        const updates = [];
        
        settingsForm.querySelectorAll('[data-key]').forEach(el => {
            const key = el.dataset.key;
            let value;
            
            if (el.type === 'checkbox') {
                value = el.checked ? 'true' : 'false';
            } else {
                value = el.value;
            }
            
            updates.push({ key, value });
        });

        try {
            const res = await fetch('/api/settings/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ updates })
            });
            
            const data = await res.json();
            
            if (data.success) {
                showToast('âœ… è¨­å®šå·²å„²å­˜', 'success');
                hasChanges = false;
                btnSave.disabled = true;
            } else {
                showToast('âŒ å„²å­˜å¤±æ•—: ' + data.error, 'error');
            }
        } catch (error) {
            showToast('âŒ å„²å­˜å¤±æ•—: ' + error.message, 'error');
        }
    }

    // ========== æ¸¬è©¦é€šçŸ¥ ==========
    async function testNotification() {
        try {
            btnTestNotify.disabled = true;
            btnTestNotify.textContent = 'ç™¼é€ä¸­...';
            
            const res = await fetch('/api/test/notification', { method: 'POST' });
            const data = await res.json();
            
            if (data.success) {
                showToast('âœ… æ¸¬è©¦é€šçŸ¥å·²ç™¼é€', 'success');
            } else {
                showToast('âŒ ' + (data.message || 'ç™¼é€å¤±æ•—'), 'error');
            }
        } catch (error) {
            showToast('âŒ ' + error.message, 'error');
        } finally {
            btnTestNotify.disabled = false;
            btnTestNotify.textContent = 'ğŸ“± æ¸¬è©¦é€šçŸ¥';
        }
    }

    // ========== å·¥å…·å‡½æ•¸ ==========
    function markChanged() {
        hasChanges = true;
        btnSave.disabled = false;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showToast(message, type = 'info') {
        toast.textContent = message;
        toast.className = `toast show ${type}`;
        setTimeout(() => {
            toast.className = 'toast';
        }, 3000);
    }

    // å…¨åŸŸå‡½æ•¸ï¼ˆçµ¦ onclick ç”¨ï¼‰
    window.selectCategory = selectCategory;

    // å•Ÿå‹•
    init();
    </script>
</body>
</html>
